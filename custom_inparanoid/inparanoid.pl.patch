--- a/inparanoid.pl	2009-10-09 16:51:00.000000000 +0200
+++ b/inparanoid.pl	2014-05-07 10:56:55.295165428 +0200
@@ -1,39 +1,39 @@
-#! /usr/bin/perl
+#!/usr/bin/perl
 ###############################################################################
 # InParanoid version 4.1
-# Copyright (C) Erik Sonnhammer, Kristoffer Forslund, Isabella Pekkari, 
+# Copyright (C) Erik Sonnhammer, Kristoffer Forslund, Isabella Pekkari,
 # Ann-Charlotte Berglund, Maido Remm, 2007
 #
-# This program is provided under the terms of a personal license to the recipient and may only 
+# This program is provided under the terms of a personal license to the recipient and may only
 # be used for the recipient's own research at an academic insititution.
 #
 # Distribution of the results of this program must be discussed with the authors.
-# For using this program in a company or for commercial purposes, a commercial license is required. 
+# For using this program in a company or for commercial purposes, a commercial license is required.
 # Contact Erik.Sonnhammer@sbc.su.se in both cases
 #
 # Make sure that Perl XML libraries are installed!
 #
-# NOTE: This script requires blastall (NCBI BLAST) version 2.2.16 or higher, that supports 
+# NOTE: This script requires blastall (NCBI BLAST) version 2.2.16 or higher, that supports
 # compositional score matrix adjustment (-C2 flag).
 
-my $usage =" Usage: inparanoid.pl <FASTAFILE with sequences of species A> <FASTAFILE with sequences of species B> [FASTAFILE with sequences of species C]
+my $usage =" Usage: inparanoid.pl [--blast-only] <FASTAFILE with sequences of species A> <FASTAFILE with sequences of species B> [FASTAFILE with sequences of species C]
 
 ";
 
 ###############################################################################
-# The program calculates orthologs between 2 datasets of proteins 
+# The program calculates orthologs between 2 datasets of proteins
 # called A and B. Both datasets should be in multi-fasta file
-# - Additionally, it tries to assign paralogous sequences (in-paralogs) to each 
+# - Additionally, it tries to assign paralogous sequences (in-paralogs) to each
 #   thus forming paralogous clusters. 
 # - Confidence of in-paralogs is calculated in relative scale between 0-100%.
 #   This confidence value is dependent on how far is given sequence from the
 #   seed ortholog of given group
-# - Confidence of groups can be calculated with bootstrapping. This is related 
+# - Confidence of groups can be calculated with bootstrapping. This is related
 #   to score difference between best hit and second best hit.
 # - Optionally it can use a species C as outgroup.
 
 ###############################################################################
-# You may need to run the following command manually to increase your 
+# You may need to run the following command manually to increase your
 # default datasize limit: 'limit datasize 500000 kb'
 
 ###############################################################################
@@ -47,7 +47,8 @@
 $blast_two_passes = 1;  # Set to 1 to run 2-pass strategy                     #
                  # (strongly recommended, but slower)                         #
 $run_inparanoid = 1;
-$use_bootstrap = 1;# Use bootstrapping to estimate the confidence of orthologs#
+# quickparanoid does not use orthologs cobnfidence, safe to disable.
+$use_bootstrap = 0;# Use bootstrapping to estimate the confidence of orthologs#
                    # Needs additional programs 'seqstat.jar' and 'blast2faa.pl'
 $use_outgroup = 0; # Use proteins from the third genome as an outgroup        #
                    # Reject best-best hit if outgroup sequence is MORE        #
@@ -55,14 +56,41 @@
                    # (by more than $outgroup_cutoff bits)                     #
 
 # Define location of files and programs:
-#$blastall = "blastall -VT"; #Remove -VT for blast version 2.2.12 or earlier
-$blastall = "blastall";  #Add -aN to use N processors
-$formatdb = "formatdb"; 
-$seqstat = "seqstat.jar";
-$blastParser = "blast_parser.pl";
-
-$matrix = "BLOSUM62"; # Reasonable default for comparison of eukaryotes.
-#$matrix = "BLOSUM45"; #(for prokaryotes),
+# Detect the number of CPUs/cores (will probably work only in bash).
+my $num_cpus = `ls -d /sys/devices/system/cpu/cpu[[:digit:]]* | wc -w`;
+chomp($num_cpus);
+print "Detected $num_cpus CPUs/cores.\n";
+# Proper method:
+#use Sys::Info;
+#use Sys::Info::Constants qw( :device_cpu );
+#my $info = Sys::Info->new;
+#my $cpu  = $info->device( CPU => %options );
+#printf "CPU: %s\n", scalar($cpu->identify)  || 'N/A';
+#printf "CPU speed is %s MHz\n", $cpu->speed || 'N/A';
+#printf "There are %d CPUs\n"  , $cpu->count || 1;
+#printf "CPU load: %s\n"       , $cpu->load  || 0;
+
+# To run inparanoid.pl itself in parallel, num_cpus should be limited.
+# Comment out the line below for all-cpus blast.
+$num_cpus = "1";
+
+# Note: outgroup code was not checked for compatibility with running multiple parallel inparanoid processes.
+
+$blastall = "blastall -a $num_cpus";  #Add -aN to use N processors; add -V, -VT to emulate older BLAST.
+$formatdb = "formatdb";
+
+# Trying to avoid absolute hard-coded paths.
+use Cwd 'abs_path';
+use File::Basename 'dirname';
+my $inpadir = dirname(abs_path($0)); # or dirname(__FILE__), from use File::Basename
+
+$seqstat = "$inpadir/seqstat.jar";
+$blastParser = "$inpadir/blast_parser.pl";
+
+#$matrix = "BLOSUM62"; # Reasonable default for comparison of eukaryotes.
+$matrix = "BLOSUM45"; #(for prokaryotes),
+# For seqstat.jar, which requires the file and not simply the name of the matrix.
+$matrix_full = "$inpadir/BLOSUM45";
 #$matrix = "BLOSUM80"; #(orthologs within metazoa),
 #$matrix = "PAM70";
 #$matrix = "PAM30";
@@ -75,7 +103,7 @@
                   # Each inparalog is on separate line                         #
 $html = 1;        # HTML-format output                                         #
 
-# Algorithm parameters:                                                        
+# Algorithm parameters:
 # Default values should work without problems.
 # MAKE SURE, however, that the score cutoff here matches what you used for BLAST!
 $score_cutoff = 40;    # In bits. Any match below this is ignored             #
@@ -97,16 +125,23 @@
 ###############################################################################
 # No changes should be required below this line                               #
 ###############################################################################
-$ENV{CLASSPATH} = "./$seqstat" if ($use_bootstrap);
+$ENV{CLASSPATH} = "$seqstat" if ($use_bootstrap);
 
 if (!@ARGV){
     print STDERR $usage;
     exit 1;
 }
 
+if ($ARGV[0] eq '--blast-only') {
+    $run_inparanoid = 0;
+    $run_blast = 1;
+    # Also suppress output when blasting-only.
+    $output = 0;
+    shift(@ARGV);
+}
+
 if ((@ARGV < 2) and ($run_inparanoid)){
     print STDERR "\n When \$run_inparanoid=1, at least two distinct FASTA files have to be specified.\n";
-
     print STDERR $usage;
     exit 1;
 }
@@ -116,10 +151,27 @@
     exit 1;
 }
 
-# Input files:                                                            
-$fasta_seq_fileA = "$ARGV[0]";                                            
-$fasta_seq_fileB = "$ARGV[1]";                                            
-$fasta_seq_fileC = "$ARGV[2]" if ($use_outgroup); # This is outgroup file  
+# Check if output files already exist, and exit if they do.
+$outputfile = "Output." . $ARGV[0] . "-" . $ARGV[1];
+$htmlfile = "orthologs." . $ARGV[0] . "-" . $ARGV[1] . ".html";
+$filename = "table." . $ARGV[0] . "-" . $ARGV[1];
+$filename2 = "sqltable." . $ARGV[0] . "-" . $ARGV[1];
+if (-e $filename2) {
+    print "Primary output file $filename2 exists, skipping the analysis.\n";
+    if (-e $outputfile && -e $htmlfile && -e $filename && -e $filename2) {
+        print "All 4 expected output files exist:\n";
+        print "\t$outputfile\n";
+        print "\t$htmlfile\n";
+        print "\t$filename\n";
+        print "\t$filename2\n";
+    }
+    exit;
+}
+
+# Input files:
+$fasta_seq_fileA = "$ARGV[0]";
+$fasta_seq_fileB = "$ARGV[1]";
+$fasta_seq_fileC = "$ARGV[2]" if ($use_outgroup); # This is outgroup file.
 
 my $blast_outputAB = $fasta_seq_fileA . "-" . $fasta_seq_fileB;
 my $blast_outputBA = $fasta_seq_fileB . "-" . $fasta_seq_fileA;
@@ -162,7 +214,6 @@
 my @confB;      # Confidence values for orthologous groups 
 my $prev_time = 0;
 
-$outputfile = "Output." . $ARGV[0] . "-" . $ARGV[1];
 if ($output){
     open OUTPUT, ">$outputfile" or warn "Could not write to OUTPUT file $filename\n";
 }
@@ -179,8 +230,7 @@
 	chomp;
 	s/\>//;
 	@tmp = split(/\s+/);
-	#$name = substr($tmp[0],0,25);
-	$name = $tmp[0];
+	$name = $tmp[0]; #$name = substr($tmp[0],0,25);
 	$idA{$name} = int($id);
 	$nameA[$id] = $name;
     }
@@ -206,8 +256,7 @@
 	    chomp;
 	    s/\>//;
 	    @tmp = split(/\s+/);
-	    #$name = substr($tmp[0],0,25);
-	    $name = $tmp[0];
+	    $name = $tmp[0]; #$name = substr($tmp[0],0,25);
 	    $idB{$name} = int($id);
 	    $nameB[$id] = $name;
 	}
@@ -233,8 +282,7 @@
 	    chomp;
 	    s/\>//;
 	    @tmp = split(/\s+/);
-	    #$name = substr($tmp[0],0,25);
-	    $name = $tmp[0];
+	    $name = $tmp[0]; #$name = substr($tmp[0],0,25);
 	    $idC{$name} = int($id);
 	    $nameC[$id] = $name;
 	}
@@ -255,30 +303,69 @@
 #################################################
 # Run BLAST if not done already
 #################################################
-if ($run_blast){
+
+# Edited to only run BLAST if the 4 files do not exist already.
+if ($run_blast && !(-e $blast_outputAA && -e $blast_outputAB && -e $blast_outputBA && -e $blast_outputBB) ) {
     print "Trying to run BLAST now - this may take several hours ... or days in worst case!\n";
     print STDERR "Formatting BLAST databases\n";
-    system ("$formatdb -i $fasta_seq_fileA");
-    system ("$formatdb -i $fasta_seq_fileB") if (@ARGV >= 2);
-    system ("$formatdb -i $fasta_seq_fileC") if ($use_outgroup);   
+    # For parallel execution:
+    # - check if database file already exists to avoid overwriting;
+    # - do not clean up database files - leave this to parent process, or add
+    #   a new --cleanup option;
+    # - avoid creating formatdb.log (redirect to either /dev/stdout or /dev/null).
+    if (-e "$fasta_seq_fileA.phr" && -e "$fasta_seq_fileA.pin" && -e "$fasta_seq_fileA.psq") {
+        print "re-using BLASTdb for $fasta_seq_fileA\n";
+    }
+    else {
+        system ("$formatdb -i $fasta_seq_fileA");
+    }
+    if (@ARGV >= 2 && -e "$fasta_seq_fileB.phr" && -e "$fasta_seq_fileB.pin" && -e "$fasta_seq_fileB.psq") {
+        print "re-using BLASTdb for $fasta_seq_fileB\n";
+    }
+    else {
+        system ("$formatdb -i $fasta_seq_fileB");
+    }
+    if ($use_outgroup && -e "$fasta_seq_fileC.phr" && -e "$fasta_seq_fileC.pin" && -e "$fasta_seq_fileC.psq") {
+        print "re-using BLASTdb for $fasta_seq_fileC\n";
+    }
+    else {
+        system ("$formatdb -i $fasta_seq_fileC");
+    }
     print STDERR "Done formatting\nStarting BLAST searches...\n";
 
-# Run blast only if the files do not already exist is not default. 
-# NOTE: you should have done this beforehand, because you probably
-# want two-pass blasting anyway which is not implemented here
-# this is also not adapted to use specific compositional adjustment settings
-# and might not use the proper blast parser...
+# Run blast only if the files do not already exist is now the default.
 
-    do_blast ($fasta_seq_fileA, $fasta_seq_fileA, $A, $A, $blast_outputAA);
+    # Edited to allow re-using BLAST results.
+    if (-e $blast_outputAA) {
+        print "Re-using BLAST result $blast_outputAA.\n";
+    }
+    else {
+        do_blast ($fasta_seq_fileA, $fasta_seq_fileA, $A, $A, $blast_outputAA);
+    }
 
     if (@ARGV >= 2) {
-      do_blast ($fasta_seq_fileA, $fasta_seq_fileB, $B, $B, $blast_outputAB);
-      do_blast ($fasta_seq_fileB, $fasta_seq_fileA, $A, $A, $blast_outputBA);
-      do_blast ($fasta_seq_fileB, $fasta_seq_fileB, $B, $B, $blast_outputBB);
+        # Edited to allow re-using BLAST results.
+        if (-e $blast_outputAB) {
+            print "Re-using BLAST result $blast_outputAB.\n";
+        }
+        else {
+            do_blast ($fasta_seq_fileA, $fasta_seq_fileB, $B, $B, $blast_outputAB);
+        }
+        if (-e $blast_outputBA) {
+            print "Re-using BLAST result $blast_outputBA.\n";
+        }
+        else {
+            do_blast ($fasta_seq_fileB, $fasta_seq_fileA, $A, $A, $blast_outputBA);
+        }
+        if (-e $blast_outputBB) {
+            print "Re-using BLAST result $blast_outputBB.\n";
+        }
+        else {
+            do_blast ($fasta_seq_fileB, $fasta_seq_fileB, $B, $B, $blast_outputBB);
+        }
     }
 
     if ($use_outgroup){
-
 	do_blast ($fasta_seq_fileA, $fasta_seq_fileC, $A, $C, $blast_outputAC);
 	do_blast ($fasta_seq_fileB, $fasta_seq_fileC, $B, $C, $blast_outputBC);
     }
@@ -290,12 +377,16 @@
     }
     print STDERR "Done BLAST searches. ";
 
-} else {
-	print STDERR "Skipping blast! \n";
 }
+else {
+    print STDERR "Skipping blast!\n";
+}
+
+#################################################
+
 
-if ($run_inparanoid){
-    print STDERR "Starting ortholog detection...\n";   
+if ($run_inparanoid) {
+    print STDERR "Starting ortholog detection...\n";
 #################################################
 # Read in best hits from blast output file AB
 #################################################
@@ -311,7 +402,7 @@
 		print STDERR "AB ok\n";
 	    }
 	    next;
-	} 
+	}
 
 	$q = $Fld[0];
 	$m = $Fld[1];
@@ -361,16 +452,15 @@
 		print STDERR "BA ok\n";
 	    }
 	    next;
-	} 
+	}
 
 	$q = $Fld[0];
 	$m = $Fld[1];
 	$idQ = $idB{$q};
-	$idM = $idA{$m};	 
+	$idM = $idA{$m};
 	$score = $Fld[2];
 	
 	next if (!overlap_test(@Fld));
-	
 	next if ($score < $score_cutoff);
 	
 	if(!$count || $q ne $oldq){
@@ -383,7 +473,7 @@
 	++$hit;
 	$hitBA[$idQ][$hit] = int($idM);
 #	printf ("hitBA[%d][%d] = %d\n",$idQ,$hit,$idM);
-	$scoreBA{"$idQ:$idM"} = $score;   
+	$scoreBA{"$idQ:$idM"} = $score;
 	$scoreAB{"$idM:$idQ"} = $score_cutoff if ($scoreAB{"$idM:$idQ"} < $score_cutoff); # Initialize missing scores
 	$old_idQ = $idQ;
 #    }
@@ -399,7 +489,6 @@
 ###################################################################################################################################### Modification by Isabella 1
 
 	# I removed the time consuming all vs all search and equalize scores for all pairs where there was a hit
-
     	foreach my $key (keys %scoreAB) {
 
 		my ($a, $b) = split(':', $key);
@@ -452,11 +541,11 @@
 		$tmp = $hitAB[$idA][$hit];
 		$hitAB[$idA][$hit] = $hitAB[$idA][$hit+1];
 		$hitAB[$idA][$hit+1] = $tmp;
-		--$hit if ($hit > 1);      
+		--$hit if ($hit > 1);
 	    }
 	}
 	$bestscore = $bestscoreAB[$idA] = $scoreAB{"$idA:$hitAB[$idA][1]"};
-	$besthitAB[$idA] = $hitAB[$idA][1];   
+	$besthitAB[$idA] = $hitAB[$idA][1];
 	for $hit (2..$hitnAB[$idA]){
 	    if ($bestscore - $scoreAB{"$idA:$hitAB[$idA][$hit]"} <= $grey_zone){
 		$besthitAB[$idA] .= " $hitAB[$idA][$hit]";
@@ -470,7 +559,7 @@
 #    printf ("besthitAB[%d] = hitAB[%d][%d] = %d\n",$idA,$idA,$hit,$besthitAB[$idA]);
 	
     }
-    
+
     for $idB(1..$B){
 #    print "Loop index = $idB\n";
 	next if (!($hitnBA[$idB]));
@@ -494,19 +583,19 @@
 	undef $is_besthitBA[$idB]; # Create index that we can check later
 	grep (vec($is_besthitBA[$idB],$_,1) = 1, split(/ /,$besthitBA[$idB]));
 #    printf ("besthitBA[%d] = %d\n",$idA,$besthitAB[$idA]);
-    }      
-    
+    }
+
     if ($show_times){
 	($user_time,,,) = times;
 	printf ("Reading and sorting homologs took %.2f seconds\n", ($user_time - $prev_time));
 	$prev_time = $user_time;
     }
-    
+
 ######################################################
 # Now find orthologs:
 ######################################################
     $o = 0;
-    
+
     for $i(1..$A){   # For each ID in file A
 	if (defined $besthitAB[$i]){
 	    @besthits = split(/ /,$besthitAB[$i]);
@@ -523,7 +612,7 @@
 		printf ("%-20s\t%d\t%-20s\t", $nameA[$i], $bestscoreAB[$i], $nameB[$hit]) if ($debug == 2);
 		print "$bestscoreBA[$hit]\t$besthitBA[$hit]\n" if ($debug == 2);
 	    }
-	}   
+	}
     }
     print "$o ortholog candidates detected\n" if ($debug);
 #####################################################
@@ -552,8 +641,6 @@
 
    # Add the information to the new arrays in the orer specifeid by the index array
    for (my $index_in_list = 0; $index_in_list < scalar @score_id_sorted_position_list; $index_in_list++) {
-	
-
 	my $old_index = $score_id_sorted_position_list[$index_in_list];
 	$new_ortoA[$index_in_list + 1] = $ortoA[$old_index];
 	$new_ortoB[$index_in_list + 1] = $ortoB[$old_index];
@@ -570,15 +657,15 @@
 #	    $tempA =  $ortoA[$i];
 #	    $tempB =  $ortoB[$i];
 #	    $tempS =  $ortoS[$i];
-#	    
+#
 #	    $ortoA[$i] = $ortoA[$i+1];
 #	    $ortoB[$i] = $ortoB[$i+1];
 #	    $ortoS[$i] = $ortoS[$i+1];
-#	    
+#
 #	    $ortoA[$i+1] = $tempA;
 #	    $ortoB[$i+1] = $tempB;
 #	    $ortoS[$i+1] = $tempS;
-#	    
+#
 #	    --$i if ($i > 1);
 #	}
 #    }
@@ -590,15 +677,15 @@
 #	    $tempA =  $ortoA[$i];
 #	    $tempB =  $ortoB[$i];
 #	    $tempS =  $ortoS[$i];
-#	    
+#
 #	    $ortoA[$i] = $ortoA[$i+1];
 #	    $ortoB[$i] = $ortoB[$i+1];
 #	    $ortoS[$i] = $ortoS[$i+1];
-#	    
+#
 #	    $ortoA[$i+1] = $tempA;
 #	    $ortoB[$i+1] = $tempB;
 #	    $ortoS[$i+1] = $tempS;
-#	    
+#
 #	    --$i if ($i > 1);
 #	}
 #    }
@@ -615,7 +702,7 @@
     undef $is_ortologB;
     grep (vec($is_ortologA,$_,1) = 1, @all_ortologsA);
     grep (vec($is_ortologB,$_,1) = 1, @all_ortologsB);
-    
+
     if ($show_times){
 	($user_time,,,) = times;
 	printf ("Finding and sorting orthologs took %.2f seconds\n", ($user_time - $prev_time));
@@ -636,7 +723,7 @@
 		   print STDERR "AC ok\n";
    	       }
 	       next;
-            } 
+            }
 
 	    $q = $Fld[0];
 	    $m = $Fld[1];
@@ -644,11 +731,8 @@
 	    $idM = $idC{$m};
 	    $score = $Fld[2];
 	    next unless (vec($is_ortologA,$idQ,1));
-	    
 	    next if (!overlap_test(@Fld));
-
 	    next if ($score < $score_cutoff);
-
 	    next if ($count and ($q eq $oldq));
 	    # Only comes here if this is the best hit:
 	    $besthitAC[$idQ] = $idM; 
@@ -671,7 +755,7 @@
 		   print STDERR "BC ok\n";
    	       }
 	       next;
-            } 
+            }
 
 	    $q = $Fld[0];
 	    $m = $Fld[1];
@@ -679,11 +763,8 @@
 	    $idM = $idC{$m};
 	    $score = $Fld[2];
 	    next unless (vec($is_ortologB,$idQ,1));
-	    
 	    next if (!overlap_test(@Fld));
-
 	    next if ($score < $score_cutoff);
-
 	    next if ($count and ($q eq $oldq));
 	    # Only comes here if this is the best hit:
 	    $besthitBC[$idQ] = $idM;
@@ -739,22 +820,19 @@
 		print STDERR "AA ok\n";
 	    }
 	    next;
-	} 
+	}
 
 	$q = $Fld[0];
 	$m = $Fld[1];
 	$score = $Fld[2];
 	next unless (vec($is_ortologA,$idA{$q},1));
-	
 	next if (!overlap_test(@Fld));
-
 	next if ($score < $score_cutoff);
-
 	if(!$count || $q ne $oldq){ # New query 
 	    $max_hit = $hit if ($hit > $max_hit);
 	    $hit = 0;
 	    $oldq = $q;
-	}   
+	}
 	++$hit;
 	++$count;
 	$scoreAA{"$idA{$q}:$idA{$m}"}  = int($score + 0.5);
@@ -772,7 +850,6 @@
     open BB, "$blast_outputBB" or die "Blast output file B->B is missing\n";
     while (<BB>) {
 	chomp;                  # strip newline
-	
 	@Fld = split(/\s+/);    # Get query and match names
 
 	if( scalar @Fld < 9 ){
@@ -780,17 +857,15 @@
 		print STDERR "BB ok\n";
 	    }
 	    next;
-	} 
+	}
 
 	$q = $Fld[0];
 	$m = $Fld[1];
 	$score = $Fld[2];
 	next unless (vec($is_ortologB,$idB{$q},1));
-	
 	next if (!overlap_test(@Fld));
-
 	next if ($score < $score_cutoff);
-	
+
 	if(!$count || $q ne $oldq){ # New query 
 	    $max_hit = $hit if ($hit > $max_hit);
 	    $oldq = $q;
@@ -822,10 +897,10 @@
 	$idB = $ortoB[$i];
 	local @membersA = ();
 	local @membersB = ();
-	
+
 	undef $is_paralogA[$i];
 	undef $is_paralogB[$i];
-	
+
 	print "$i: Ortholog pair $nameA[$idA] and $nameB[$idB]. $hitnAA[$idA] hits for A and $hitnBB[$idB] hits for B\n"  if ($debug);
 	# Check if current ortholog is already clustered:
 	for $j(1..($i-1)){
@@ -862,7 +937,7 @@
 	    }
 	    # Overlap type 5:
 	    # All clusters that were overlapping, but not catched by previous "if" statements will be DIVIDED!
-	} 
+	}
 	next if ($merge[$i] < 0); # This cluster should be deleted
 ##### Check for paralogs in A
 	$N = $hitnAA[$idA];
@@ -896,21 +971,21 @@
 			if($debug == 2){
 			    print "      $nameA[$hitID] is already in cluster $k, together with:";
 			    print " $nameA[$ortoA[$k]] and $nameB[$ortoB[$k]] ";
-			    print "($scoreAA{\"$ortoA[$k]:$hitID\"})";         
+			    print "($scoreAA{\"$ortoA[$k]:$hitID\"})";
 			}
 			if (($confPA[$hitID] >= $conf_here) and 
 			    ($j != 1)){ # The seed ortholog CAN NOT remain there
 			    print " and remains there.\n" if ($debug == 2);
 			    $paralogs = 0; # No action
 			}
-			else { # Ortholog of THIS cluster is closer than ortholog of competing cluster $k 
+			else { # Ortholog of THIS cluster is closer than ortholog of competing cluster $k
 			    print " and should be moved here!\n" if ($debug == 2); # Remove from other cluster, add to this cluster
 			    @membersAK = split(/ /, $paralogsA[$k]); # This array contains IDs
 			    $paralogsA[$k] = "";# Remove all paralogs from cluster $k
 				@tmp = ();
-			    for $m(@membersAK){   
-				push(@tmp,$m) if ($m != $hitID); # Put other members back  
-			    }  
+			    for $m(@membersAK){
+				push(@tmp,$m) if ($m != $hitID); # Put other members back
+			    }
 			    $paralogsA[$k] = join(' ',@tmp);
 			    undef $is_paralogA[$k]; # Create index that we can check later
 			    grep (vec($is_paralogA[$k],$_,1) = 1, @tmp);
@@ -919,8 +994,8 @@
 		    }
 		}
 		next if (! $paralogs); # Skip that paralog - it is already in cluster $k
-		push (@membersA,$hitID); # Add this hit to paralogs of A 
-	    } 
+		push (@membersA,$hitID); # Add this hit to paralogs of A
+	    }
 	}
 	# Calculate confidence values now:
 	@tmp = ();
@@ -929,12 +1004,12 @@
 		if ($scoreAA{"$idA:$idP"} == $scoreAA{"$idA:$idA"}){
 		    $confPA[$idP] = 1.00;
 		}
-		else{ 
+		else{
 		    $confPA[$idP] = 0.00;
 		}
 	    }
-	    else{ 
-		$confPA[$idP] = ($scoreAA{"$idA:$idP"} - $ortoS[$i]) / 
+	    else{
+		$confPA[$idP] = ($scoreAA{"$idA:$idP"} - $ortoS[$i]) /
 		    ($scoreAA{"$idA:$idA"} - $ortoS[$i]);
 	    }
 	    push (@tmp, $idP) if ($confPA[$idP] >= $conf_cutoff); # If one wishes to use only significant paralogs
@@ -942,7 +1017,7 @@
 	@membersA = @tmp;
 	########### Merge if necessary:
 	if ($merge[$i] > 0){ # Merge existing cluster with overlapping cluster
-	    @tmp = split(/ /,$paralogsA[$merge[$i]]);      
+	    @tmp = split(/ /,$paralogsA[$merge[$i]]);
 	    for $m (@membersA){
 		push (@tmp, $m)  unless (vec($is_paralogA[$merge[$i]],$m,1));
 	    }
@@ -955,8 +1030,8 @@
 	    $paralogsA[$i] = join(' ',@membersA);
 	    undef $is_paralogA; # Create index that we can check later
 	    grep (vec($is_paralogA[$i],$_,1) = 1, @membersA);
-	}  
-##### The same procedure for species B:   
+	}
+##### The same procedure for species B:
 	$N = $hitnBB[$idB];
 	for $j(1..$N){
 	    $hitID = $hitBB[$idB][$j];
@@ -968,7 +1043,7 @@
 		    printf ("%-20s: %-20s", $nameB[$idB], $nameB[$hitID]);
 		    print "\t$scoreBB{\"$idB:$hitID\"} : ";
 		    print "$bestscoreBA[$idB] : $bestscoreBA[$hitID]\n";
-		}         
+		}
 		$paralogs = 1;
 		if ($scoreBB{"$idB:$idB"} == $ortoS[$i]){
 		    if ($scoreBB{"$idB:$hitID"} == $scoreBB{"$idB:$idB"}){
@@ -996,14 +1071,14 @@
 			    print " and remains there.\n" if ($debug == 2);
 			    $paralogs = 0; # No action
 			}
-			else { # Ortholog of THIS cluster is closer than ortholog of competing cluster $k 
+			else { # Ortholog of THIS cluster is closer than ortholog of competing cluster $k
 			    print " and should be moved here!\n" if ($debug == 2); # Remove from other cluster, add to this cluster
 			    @membersBK = split(/ /, $paralogsB[$k]); # This array contains names, not IDs
 			    $paralogsB[$k] = "";
 			    @tmp = ();
-			    for $m(@membersBK){   
-				push(@tmp,$m) if ($m != $hitID); # Put other members back  
-			    }  
+			    for $m(@membersBK){
+				push(@tmp,$m) if ($m != $hitID); # Put other members back
+			    }
 			    $paralogsB[$k] = join(' ',@tmp);
 			    undef $is_paralogB[$k]; # Create index that we can check later
 			    grep (vec($is_paralogB[$k],$_,1) = 1, @tmp);
@@ -1025,17 +1100,17 @@
 		else{
 		    $confPB[$idP] = 0.0;
 		}
-	    }   
+	    }
 	    else{
 		$confPB[$idP] = ($scoreBB{"$idB:$idP"} - $ortoS[$i]) / 
 		    ($scoreBB{"$idB:$idB"} - $ortoS[$i]);
 	    }
 	    push (@tmp, $idP) if ($confPB[$idP] >= $conf_cutoff); # If one wishes to use only significant paralogs
-	}   
+	}
 	@membersB = @tmp;
 	########### Merge if necessary:
 	if ($merge[$i] > 0){ # Merge existing cluster with overlapping cluster
-	    @tmp = split(/ /,$paralogsB[$merge[$i]]);      
+	    @tmp = split(/ /,$paralogsB[$merge[$i]]);
 	    for $m (@membersB){
 		push (@tmp, $m)  unless (vec($is_paralogB[$merge[$i]],$m,1));
 	    }
@@ -1096,7 +1171,7 @@
 	}
 	if ($na and ($nb == 0)){
 	    print "Warning: empty B cluster $i\n";
-	    for $m (@membersA){	  
+	    for $m (@membersA){
 		$bestscore = 0;
 		$bestgroup = 0;
 		$bestmatch = 0;
@@ -1125,15 +1200,13 @@
 	    }
 	}
     }
-    
+
     &clean_up(1);
 ###################
-    $htmlfile = "orthologs." . $ARGV[0] . "-" . $ARGV[1] . ".html";
     if ($html){
-	open HTML, ">$htmlfile" or warn "Could not write to HTML file $filename\n";
+	open HTML, ">$htmlfile" or warn "Could not write to HTML file $htmlfile\n";
     }
-    
-    
+
     if ($output){
 	print OUTPUT "\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\n";
 	print OUTPUT "$o groups of orthologs\n";
@@ -1165,14 +1238,15 @@
 # Check for alternative orthologs, sort paralogs by confidence and print results
 # ##############################################################################
     if ($use_bootstrap and $debug){
+    # WARNING: this code is NOT SAFE for parallel execution of inparanoid.
 	open FF, ">BS_vs_bits" or warn "Could not write to file BS_vs_bits\n";
     }
     for $i(1..$o){
 	@membersA = split(/ /, $paralogsA[$i]);
-	@membersB = split(/ /, $paralogsB[$i]);		 
+	@membersB = split(/ /, $paralogsB[$i]);
 	$message = "";
 	$htmlmessage = "";
-	
+
 	$idB = $ortoB[$i];
 	$nB = $hitnBA[$idB];
 	for $idA(@membersA){
@@ -1187,7 +1261,7 @@
 		# 1. Don't consider sequences that are already in this cluster
 		next if (vec($is_paralogA[$i],$idH,1));
 		next if ($confPA[$idH] > 0); # If $conf_cutoff > 0 idH might be incide circle, but not paralog
-		
+
 		# 2. Check if candidate for alternative ortholog is already clustered in stronger clusters
 		$in_other_cluster = 0;
 		for $k(1..($i-1)){ # Check if current ortholog is already clustered
@@ -1196,8 +1270,8 @@
 			last;
 		    }
 		}
-#		 next if ($in_other_cluster); # This hit is clustered in cluster $k. It cannot be alternative ortholog 
-		
+#		 next if ($in_other_cluster); # This hit is clustered in cluster $k. It cannot be alternative ortholog
+
 		# 3. The best hit of candidate ortholog should be ortoA or at least to belong into this cluster
 		@besthits = split (/ /,$besthitAB[$idH]);
 		$this_family = 0;
@@ -1222,19 +1296,19 @@
 	    $message .= sprintf("\n");
 	    if ($html){
 		if ($bsA[$idA] < 0.75){
-		    $htmlmessage .= sprintf("<font color=\"red\">"); 			
+		    $htmlmessage .= sprintf("<font color=\"red\">");
 		}
 		elsif ($bsA[$idA] < 0.95){
 		    $htmlmessage .= sprintf("<font color=\"\#FFCC00\">");
-		}  
+		}
 		else {
 		    $htmlmessage .= sprintf("<font color=\"green\">");
-		}  
+		}
 		$htmlmessage .= sprintf("Bootstrap support for %s as seed ortholog is %d%%.\n", $nameA[$idA], 100*$bsA[$idA]);
 		$htmlmessage .= sprintf("Alternative seed ortholog is %s (%d bits away from this cluster)\n", $nameA[$idH], $confA[$i]) if ($bsA[$idA] < 0.75);
 		$htmlmessage .= sprintf("</font>");
-	    } 
-	    printf (FF "%s\t%d\t%d\n", $nameA[$idA], $confA[$i], 100*$bsA[$idA]) if ($use_bootstrap and $debug); 
+	    }
+	    printf (FF "%s\t%d\t%d\n", $nameA[$idA], $confA[$i], 100*$bsA[$idA]) if ($use_bootstrap and $debug);
 	}
 	########
 	$idA = $ortoA[$i];
@@ -1244,7 +1318,7 @@
 	    $nB = $hitnBA[$idB];
 	    $confB[$i] = $ortoS[$i]; # default
 	    $bsB[$idB] = 1.0;
-	    
+
 	    for $j(1..$nA){ # For all AB hits of given ortholog
 		$idH = $hitAB[$idA][$j];
 		# ############### Some checks for alternative orthologs:
@@ -1287,7 +1361,7 @@
 	    if ($html){
 		if ($bsB[$idB] < 0.75){
 		    $htmlmessage .= sprintf("<font color=\"red\">");
-		}      
+		}
 		elsif ($bsB[$idB] < 0.95){
 		    $htmlmessage .= sprintf("<font color=\"\#FFCC00\">");
 		}
@@ -1299,13 +1373,13 @@
 		$htmlmessage .= sprintf("</font>");
 	    }
 	    printf (FF "%s\t%d\t%d\n", $nameB[$idB], $confB[$i], 100*$bsB[$idB]) if ($use_bootstrap and $debug);
-	}		
+	}
 	close FF;
 	########### Print header ###############
 	if ($output){
 	    print OUTPUT "___________________________________________________________________________________\n";
 	    print OUTPUT "Group of orthologs #" . $i .". Best score $ortoS[$i] bits\n";
-		print OUTPUT "Score difference with first non-orthologous sequence - ";
+	    print OUTPUT "Score difference with first non-orthologous sequence - ";
 	    printf (OUTPUT "%s:%d   %s:%d\n", $fasta_seq_fileA,$confA[$i],$fasta_seq_fileB,$confB[$i]);
 	}
 	
@@ -1314,8 +1388,8 @@
 	    print HTML "<hr WIDTH=\"100%\">";
 	    print HTML "<h3>";
 	    print HTML "Group of orthologs #" . $i .". Best score $ortoS[$i] bits<br>\n";
-		print HTML "Score difference with first non-orthologous sequence - ";
-	    printf (HTML "%s:%d   %s:%d</h3><pre>\n", $fasta_seq_fileA,$confA[$i],$fasta_seq_fileB,$confB[$i]);			
+	    print HTML "Score difference with first non-orthologous sequence - ";
+	    printf (HTML "%s:%d   %s:%d</h3><pre>\n", $fasta_seq_fileA,$confA[$i],$fasta_seq_fileB,$confB[$i]);
 	}
 	########### Sort and print members of A ############
 	$nA = @membersA;
@@ -1339,7 +1413,7 @@
 		$membersB[$m+1] = $temp;
 		--$m if ($m > 1);
 	    }
-	}   
+	}
 	$paralogsB[$i] = join(' ',@membersB); # Put them back together
 	# Print to text file and to HTML file
 	for $m (0..($nMAX-1)){
@@ -1384,9 +1458,8 @@
       close HTML;
       print "HTML output saved to $htmlfile\n";
     }
-    
+
     if ($table){
-	$filename = "table." . $ARGV[0] . "-" . $ARGV[1];
 	open F, ">$filename" or die;
 	print F "OrtoID\tScore\tOrtoA\tOrtoB\n";
 	for $i(1..$o){
@@ -1403,12 +1476,11 @@
 		printf (F "%s %.3f ", $nameB[$m], $confPB[$m]);
 	    }
 	    print F "\n";
-	}  
+	}
 	close F;
 	print "Table output saved to $filename\n";
     }
-    if ($mysql_table){
-	$filename2 = "sqltable." . $ARGV[0] . "-" . $ARGV[1];
+    if ($mysql_table) {
 	open F2, ">$filename2" or die;
 	for $i(1..$o){
 	    @membersA = split(/ /, $paralogsA[$i]);
@@ -1419,7 +1491,7 @@
 		} else {
 		    printf (F2 "%d\t%d\t%s\t%.3f\t%s\n", $i, $ortoS[$i], $ARGV[0], $confPA[$m], $nameA[$m]);
 		}
-	    }     
+	    }
 	    @membersB = split(/ /, $paralogsB[$i]);
 	    for $m (@membersB){
 		# $m =~ s/://g;
@@ -1438,13 +1510,21 @@
       printf ("Finding bootstrap values and printing took %.2f seconds\n", ($user_time - $prev_time));
       printf ("The overall execution time: %.2f seconds\n", $user_time);
     }
-    if ($run_blast) { 
-      unlink "formatdb.log";
-      unlink "$fasta_seq_fileA.phr", "$fasta_seq_fileA.pin", "$fasta_seq_fileA.psq";
-      unlink "$fasta_seq_fileB.phr", "$fasta_seq_fileB.pin", "$fasta_seq_fileB.psq" if (@ARGV >= 2);
-      unlink "$fasta_seq_fileC.phr", "$fasta_seq_fileC.pin", "$fasta_seq_fileC.psq" if ($use_outgroup);   
-    }
-  }
+}
+else {
+    print "NOT performing Inparanoid analysis, as requested.\n";
+}
+
+if ($run_blast) {
+    print "After adaptation for parallel execution, inparanoid no longer deletes *.phr, *.pin, *.psq files.\n";
+    print "Please remove these files from the parent/calling application.\n";
+    # TODO: add a new first command-line option --cleanup (similar to --blast-only), which will cleanup
+    #       the formatdb files derived from provided filenames.
+    #unlink "formatdb.log";
+    #unlink "$fasta_seq_fileA.phr", "$fasta_seq_fileA.pin", "$fasta_seq_fileA.psq";
+    #unlink "$fasta_seq_fileB.phr", "$fasta_seq_fileB.pin", "$fasta_seq_fileB.psq" if (@ARGV >= 2);
+    #unlink "$fasta_seq_fileC.phr", "$fasta_seq_fileC.pin", "$fasta_seq_fileC.psq" if ($use_outgroup);
+}
 
 ##############################################################
 # Functions:
@@ -1458,12 +1538,12 @@
     $totalA = $totalB = 0;
     # First pass: count members within each cluster
     foreach $i (1..$o) {
-	@membersA = split(/ /, $paralogsA[$i]);      
+	@membersA = split(/ /, $paralogsA[$i]);
 	$clusnA[$i] = @membersA; # Number of members in this cluster
 	$totalA += $clusnA[$i];
 	$paralogsA[$i] = join(' ',@membersA);
 	
-	@membersB = split(/ /, $paralogsB[$i]);      
+	@membersB = split(/ /, $paralogsB[$i]);
 	$clusnB[$i] = @membersB; # Number of members in this cluster
 	$totalB += $clusnB[$i];
 	$paralogsB[$i] = join(' ',@membersB);
@@ -1562,13 +1642,14 @@
 
 }
 sub bootstrap{
+    # WARNING: this function WAS NOT tested for parallel runs of inparanoid.
     my $species = shift;
     my $seq_id1 = shift; # Query ID from $species
     my $seq_id2 = shift; # Best hit ID from other species
     my $seq_id3 = shift; # Second best hit
     # Retrieve sequence 1 from $species and sequence 2 from opposite species
     my $significance = 0.0;
-    
+
     if ($species eq $fasta_seq_fileA){
 	$file1 = $fasta_seq_fileA;
 	$file2 = $fasta_seq_fileB;
@@ -1588,8 +1669,8 @@
     $seq1 = "";
     $seq2 = "";
 
-    $query_file = $seq_id1 . ".faq";                                                                              
-    open Q, ">$query_file" or die; 
+    $query_file = $seq_id1 . ".faq";
+    open Q, ">$query_file" or die;
 
     while (<A>){
 	if(/^\>/){
@@ -1616,40 +1697,40 @@
     }
     close B;
     close DB;
-    
-    system "$formatdb -i $db_file";
+
+    system "$formatdb -i $db_file -l /dev/stdout";
     # Use soft masking in 1-pass mode for simplicity.
-    system "$blastall -F\"m S\" -i $query_file -z 5000000 -d $db_file -p blastp -M $matrix -m7 | ./$blastParser 0 -a > $seq_id2.faa";
+    system "$blastall -F\"m S\" -i $query_file -z 5000000 -d $db_file -p blastp -M $matrix -m7 | $blastParser 0 -a > $seq_id2.faa";
 
     # Note: Changed score cutoff 50 to 0 for blast2faa.pl (060402).
-    # Reason: after a cluster merger a score can be less than the cutoff (50) 
-    # which will remove the sequence in blast2faa.pl.  The bootstrapping will 
+    # Reason: after a cluster merger a score can be less than the cutoff (50)
+    # which will remove the sequence in blast2faa.pl.  The bootstrapping will
     # then fail.
-    # AGAIN, updaye
-    
+    # AGAIN, update
+
     if (-s("$seq_id2.faa")){
 
-	system("java -jar $seqstat -m $matrix -n 1000 -i $seq_id2.faa > $seq_id2.bs"); # Can handle U, u
+	system("java -jar $seqstat -m $matrix_full -n 1000 -i $seq_id2.faa > $seq_id2.bs"); # Can handle U, u
 
 	if (-s("$seq_id2.bs")){
 	    open BS, "$seq_id2.bs" or die "pac failed\n";
 	    $_ = <BS>;
 	    ($dummy1,$dummy2,$dummy3,$dummy4,$significance) = split(/\s+/);
-	    close BS;	
+	    close BS;
 	}
 	else{
 	    print STDERR "pac failed\n"; # if ($debug);
 	    $significance = -0.01;
-	}	
+	}
     }
     else{
-	print STDERR "blast2faa for $query_file / $db_file failed\n"; # if ($debug);                                            
+	print STDERR "blast2faa for $query_file / $db_file failed\n"; # if ($debug);
 	$significance = 0.0; 
     }
-    
+
     unlink "$seq_id2.fas", "$seq_id2.faa", "$seq_id2.bs", "$seq_id1.faq"; 
     unlink "formatdb.log", "$seq_id2.fas.psq", "$seq_id2.fas.pin", "$seq_id2.fas.phr";
-    
+
     return $significance;
 }
 
@@ -1690,15 +1771,15 @@
 
 sub do_blast_1pass {
   my @Fld = @_;
-  
+
   # $Fld [0] is query
   # $Fld [1] is database
   # $Fld [2] is query size
   # $Fld [3] is database size
   # $Fld [4] is output name
-  
-  # Use soft masking (low complexity masking by SEG in search phase, not in alignment phase). 
-  system ("$blastall -F\"m S\" -i $Fld[0] -d $Fld[1] -p blastp -v $Fld[3] -b $Fld[3] -M $matrix -z 5000000 -m7 | ./$blastParser $score_cutoff > $Fld[4]");
+
+  # Use soft masking (low complexity masking by SEG in search phase, not in alignment phase).
+  system ("$blastall -F\"m S\" -i $Fld[0] -d $Fld[1] -p blastp -v $Fld[3] -b $Fld[3] -M $matrix -z 5000000 -m7 | $blastParser $score_cutoff > $Fld[4]");
 }
 
 sub do_blast_2pass {
@@ -1734,7 +1815,7 @@
 		}
 		else {
 			$sequencesA {$seqID} = $sequencesA {$seqID}.$aLine;
-		}		
+		}
 	}
 	close (FHA);
 
@@ -1752,49 +1833,50 @@
 		}
 		else {
 			$sequencesB {$seqID} = $sequencesB {$seqID}.$aLine;
-		}		
+		}
 	}
 	close (FHB);
 
-	# Do first pass with compositional adjustment on and soft masking.  
+	# Do first pass with compositional adjustment on and soft masking.
 	# This efficiently removes low complexity matches but truncates alignments,
 	# making a second pass necessary.
 	print STDERR "\nStarting first BLAST pass for $Fld[0] - $Fld[1] on ";
-	system("date");
-	open FHR, "$blastall -C3 -F\"m S\" -i $Fld[0] -d $Fld[1] -p blastp -v $Fld[3] -b $Fld[3] -M $matrix -z 5000000 -m7 | ./$blastParser $score_cutoff|";
+	print STDERR system("date");
+	my $command = "$blastall -C3 -F\"m S\" -i $Fld[0] -d $Fld[1] -p blastp -v $Fld[3] -b $Fld[3] -M $matrix -z 5000000 -m7 | $blastParser $score_cutoff|";
+	print STDERR "command is: $command\n";
+	open FHR, $command;
 
 	%theHits = ();
 	while (<FHR>) {
 		$aLine = $_;
 		chomp ($aLine);
 		@words = split (/\s+/, $aLine);
-
 		if (exists ($theHits {$words [0]})) {
 			$theHits {$words [0]} = $theHits {$words [0]}." ".$words [1];
 		}
 		else {
 			$theHits {$words [0]} = $words [1];
 		}
-
 	}
 	close (FHR);
 
-	$tmpdir = ".";   # May be slightly (5%) faster using the RAM disk "/dev/shm".
-	$tmpi = "$tmpdir/tmpi";
-	$tmpd = "$tmpdir/tmpd";
+	$tmpdir = "/tmp";   # May be slightly (5%) faster using the RAM disk "/dev/shm".
+	# Bound both i/d temporary files to the composite query-database name.
+	$tmpi = "$tmpdir/i-$Fld[0]-$Fld[1]";
+	$tmpd = "$tmpdir/d-$Fld[0]-$Fld[1]";
+	#print "tmpi $tmpi, tmpd $tmpd\n";
 
 	# Do second pass with compositional adjustment off to get full-length alignments.
 	print STDERR "\nStarting second BLAST pass for $Fld[0] - $Fld[1] on ";
 	system("date");
 	unlink "$Fld[4]";
 	foreach $aQuery (keys % theHits) {
-
 		# Create single-query file
 		open (FHT, ">$tmpi");
 		print FHT ">$aQuery\n".$sequencesA {">$aQuery"}."\n";
 		close (FHT);
 
-	        # Create mini-database of hit sequences
+		# Create mini-database of hit sequences
 		open (FHT, ">$tmpd");
 		foreach $aHit (split (/\s/, $theHits {$aQuery})) {
 			print FHT ">$aHit\n".$sequencesB {">$aHit"}."\n";
@@ -1803,13 +1885,20 @@
 
 		# Run Blast and add to output
 		system ("$formatdb -i $tmpd");
-		system ("$blastall -C0 -FF -i $tmpi -d $tmpd -p blastp -v $Fld[3] -b $Fld[3] -M $matrix -z 5000000 -m7 | ./$blastParser $score_cutoff >> $Fld[4]");
+		# TODO: instead of creating and writing to $tmpi, feed query sequence to blastall through stdin.
+		# see e.g. http://stackoverflow.com/questions/78091/how-can-i-capture-the-stdin-and-stdout-of-system-command-from-a-perl-script
+		# http://search.cpan.org/~rgarcia/perl-5.10.0/lib/IPC/Open2.pm
+		# possibly simpler solution example:
+		# open my $fh => "| cmd -option" or die $!; print $fh $str; close $fh or die $!;
+		system ("$blastall -C0 -FF -i $tmpi -d $tmpd -p blastp -v $Fld[3] -b $Fld[3] -M $matrix -z 5000000 -m7 | $blastParser $score_cutoff >> $Fld[4]");
 	}
+	# even if nothing was found - make sure the file exists
+	system ("touch $Fld[4]");
 
 	unlink "$tmpi", "$tmpd", "formatdb.log", "$tmpd.phr", "$tmpd.pin", "$tmpd.psq";
 }
 
-				 
+
 #   Date                                 Modification
 # --------          ---------------------------------------------------
 #
